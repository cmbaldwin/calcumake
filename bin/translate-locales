#!/usr/bin/env ruby
# Automated translation system using OpenRouter API
# Translates missing keys from English master files to all target locales

$stdout.sync = true  # Force immediate output
$stderr.sync = true

require 'bundler/setup'
require 'yaml'
require 'json'
require 'fileutils'
require 'open_router'

LOCALES_DIR = File.expand_path('../config/locales', __dir__)
MASTER_LOCALE = 'en'
MASTER_LOCALE_DIR = File.join(LOCALES_DIR, MASTER_LOCALE)
TARGET_LOCALES = ['ja', 'es', 'fr', 'ar', 'hi', 'zh-CN']
BATCH_SIZE = 50 # Keys per API request
CACHE_DIR = File.expand_path('../tmp/translation_cache', __dir__)

# Language name mapping for better API prompts
LANGUAGE_NAMES = {
  'ja' => 'Japanese',
  'es' => 'Spanish',
  'fr' => 'French',
  'ar' => 'Arabic',
  'hi' => 'Hindi',
  'zh-CN' => 'Simplified Chinese'
}

# Ensure cache directory exists
FileUtils.mkdir_p(CACHE_DIR)

# Helper to deep merge hashes
def deep_merge!(target, source)
  source.each do |key, value|
    if target[key].is_a?(Hash) && value.is_a?(Hash)
      deep_merge!(target[key], value)
    else
      target[key] = value
    end
  end
  target
end

# Load and merge all English translation files
def load_master_translations
  merged_data = {}

  # Check if en/ directory exists (new structure)
  if Dir.exist?(MASTER_LOCALE_DIR)
    # Load all YAML files from en/ directory
    en_files = Dir.glob(File.join(MASTER_LOCALE_DIR, '*.yml')).sort
    puts "ğŸ“‚ Loading English translations from #{en_files.count} files..."

    en_files.each do |file|
      data = YAML.load_file(file)
      if data && data[MASTER_LOCALE]
        deep_merge!(merged_data, data[MASTER_LOCALE])
        puts "  âœ“ Loaded #{File.basename(file)}"
      end
    end
  else
    # Fall back to single en.yml file (old structure)
    en_file = File.join(LOCALES_DIR, "#{MASTER_LOCALE}.yml")
    if File.exist?(en_file)
      data = YAML.load_file(en_file)
      merged_data = data[MASTER_LOCALE] if data
      puts "ğŸ“– Loaded #{MASTER_LOCALE}.yml (legacy single file)"
    else
      puts "âŒ Error: No English translation files found!"
      exit 1
    end
  end

  merged_data
end

def get_all_keys(hash, prefix = '')
  keys = {}
  hash.each do |key, value|
    full_key = prefix.empty? ? key : "#{prefix}.#{key}"
    if value.is_a?(Hash)
      keys.merge!(get_all_keys(value, full_key))
    else
      keys[full_key] = value
    end
  end
  keys
end

def set_nested_key(hash, key_path, value)
  keys = key_path.split('.')
  last_key = keys.pop
  current = hash

  keys.each do |key|
    unless current.is_a?(Hash)
      puts "   âš ï¸  Cannot set #{key_path} - parent is not a hash"
      return
    end
    current[key] ||= {}
    current = current[key]
  end

  if current.is_a?(Hash)
    current[last_key] = value
  else
    puts "   âš ï¸  Cannot set #{key_path} - target is not a hash"
  end
end

def check_credits(client)
  # Use the HTTP module's get method (client includes OpenRouter::HTTP)
  response = client.send(:get, path: '/credits')
  response.is_a?(Hash) ? response : JSON.parse(response)
rescue StandardError => e
  # Return error hash for caller to handle
  { 'error' => { 'message' => e.message, 'code' => 500 } }
end

def call_openrouter_api(keys_to_translate, target_language, client)
  # Prepare translation request with clear instructions
  translation_pairs = keys_to_translate.map { |k, v| "#{k}: #{v}" }.join("\n")

  prompt = <<~PROMPT
    You are a professional translator for a 3D printing management web application called CalcuMake.

    Translate the following English UI strings to #{LANGUAGE_NAMES[target_language]}.

    CRITICAL RULES:
    1. Preserve all interpolation variables EXACTLY as shown (e.g., %{name}, %{count}, etc.)
    2. Preserve HTML tags if present
    3. Keep technical terms accurate (e.g., "filament", "printer", "STL file")
    4. Use natural, professional language for UI elements
    5. Preserve currency symbols EXACTLY (Â¥, $, â‚¬, etc.) - DO NOT convert them to any other format
    6. Return ONLY the translations in the same key: value format, nothing else

    English strings to translate:
    #{translation_pairs}

    Respond with translations in this exact format:
    key: translated_value
  PROMPT

  response = client.complete(
    [
      {
        role: 'user',
        content: prompt
      }
    ],
    model: 'google/gemini-2.0-flash-001',
    extras: {
      temperature: 0.3, # Lower temperature for more consistent translations
      max_tokens: 4000
    }
  )

  content = response.dig('choices', 0, 'message', 'content')

  unless content
    raise "No content in API response: #{response.inspect}"
  end

  # Try to parse as JSON first (Gemini often returns JSON)
  translations = {}

  # Check if response is JSON wrapped in markdown code blocks
  json_match = content.match(/```(?:json)?\s*(\{.*\})\s*```/m)
  if json_match
    translations = JSON.parse(json_match[1])
  elsif content.strip.start_with?('{')
    # Direct JSON response
    translations = JSON.parse(content)
  else
    # Parse line-by-line format
    content.split("\n").each do |line|
      next if line.strip.empty?
      next if line.strip.start_with?('#') # Skip comments

      if line =~ /^(.+?):\s*(.+)$/
        key = $1.strip
        value = $2.strip
        translations[key] = value
      end
    end
  end

  translations
rescue StandardError => e
  puts "   âŒ API Error: #{e.message}"
  nil
end

def translate_batch(keys_hash, target_language, client, cache_file)
  # Check cache first
  cached_translations = {}
  if File.exist?(cache_file)
    cached_translations = JSON.parse(File.read(cache_file))
  end

  # Filter out already cached keys
  keys_to_translate = keys_hash.reject { |k, _v| cached_translations.key?(k) }

  if keys_to_translate.empty?
    puts "   ğŸ“¦ All keys cached, skipping API call"
    return cached_translations
  end

  puts "   ğŸŒ Translating #{keys_to_translate.size} keys to #{LANGUAGE_NAMES[target_language]}..."

  translations = call_openrouter_api(keys_to_translate, target_language, client)

  unless translations
    puts "   âŒ Translation failed for #{target_language}"
    puts "   This is a CRITICAL ERROR - cannot proceed without translations"
    exit 1
  end

  # Merge with cached translations
  all_translations = cached_translations.merge(translations)

  # Update cache
  File.write(cache_file, JSON.pretty_generate(all_translations))

  puts "   âœ… Translated #{translations.size} keys (#{cached_translations.size} from cache)"
  all_translations
end

def validate_translation(key, original, translated)
  # Skip validation if either value is nil
  return true if original.nil? || translated.nil?

  # Check for interpolation variables
  original_vars = original.to_s.scan(/%\{[^}]+\}/)
  translated_vars = translated.to_s.scan(/%\{[^}]+\}/)

  if original_vars.sort != translated_vars.sort
    puts "   âš ï¸  Variable mismatch in #{key}:"
    puts "      Original: #{original_vars.join(', ')}"
    puts "      Translated: #{translated_vars.join(', ')}"
    return false
  end

  true
end

# Main execution
puts "=" * 80
puts "CalcuMake Automated Translation System"
puts "Using OpenRouter API with Google Gemini 2.0 Flash (google/gemini-2.0-flash-001)"
puts "=" * 80
puts

# Check for API key
api_key = ENV['OPENROUTER_TRANSLATION_KEY'] || ENV['OPENROUTER_API_KEY']
unless api_key
  puts "âŒ Error: OPENROUTER_TRANSLATION_KEY environment variable not set"
  puts
  puts "To use this script:"
  puts "  export OPENROUTER_TRANSLATION_KEY='your-api-key'"
  puts "  bin/translate-locales"
  exit 1
end

# Configure and initialize OpenRouter client
OpenRouter.configure do |config|
  config.access_token = api_key
  config.site_name = 'CalcuMake Translation System'
  config.site_url = 'https://calcumake.com'
end

client = OpenRouter::Client.new

# Check credits/limits and validate API key
puts "ğŸ” Validating API key..."

# Try to check credits (works for provisioning keys and account-level keys)
begin
  credits_info = check_credits(client)

  if credits_info.dig('error', 'code') == 403
    # This is a regular API key, not a provisioning key - that's fine!
    # Regular keys have their own limits instead of sharing account credits
    puts "ğŸ“‹ Regular API key detected (per-key limit applies)"
    puts "âœ… API key valid"
  else
    # This is either a provisioning key or account-level key with credit info
    total_credits = credits_info['total_credits'] || 0
    used_credits = credits_info['used_credits'] || 0
    remaining_credits = total_credits - used_credits

    # If all values are 0, this might be a per-key limit situation
    if total_credits == 0 && used_credits == 0
      puts "ğŸ“‹ Per-key limit detected (usage: $#{used_credits.round(4)} of $2.00 limit)"
      puts "âœ… API key valid, proceeding with translations"
    else
      puts "ğŸ’° Credits: #{remaining_credits.round(4)} remaining (#{total_credits.round(4)} total, #{used_credits.round(4)} used)"

      if remaining_credits <= 0
        puts "âŒ ERROR: No credits remaining!"
        puts "   Please add credits to your OpenRouter account"
        puts "   Visit: https://openrouter.ai/credits"
        exit 1
      end

      if remaining_credits < 0.10
        puts "âš ï¸  WARNING: Low credits! (less than $0.10 remaining)"
        puts "   Consider adding more credits soon"
        puts "   Visit: https://openrouter.ai/credits"
      end

      puts "âœ… API key valid and credits available"
    end
  end
rescue => e
  puts "âš ï¸  Could not verify credits (key may have per-key limit): #{e.message}"
  puts "âœ… Proceeding with translation attempt..."
end

puts

# Load master locale files
# Load all English translations (from en/ directory or single file)
master_data = load_master_translations
master_keys = get_all_keys(master_data)

# Load Devise translations if they exist
devise_master_file = File.join(LOCALES_DIR, "devise.#{MASTER_LOCALE}.yml")
devise_keys = {}
if File.exist?(devise_master_file)
  devise_data = YAML.load_file(devise_master_file)
  devise_keys = get_all_keys(devise_data[MASTER_LOCALE])
  puts "ğŸ“– Loaded #{devise_keys.count} keys from devise.#{MASTER_LOCALE}.yml"
end

all_master_keys = master_keys.merge(devise_keys)
puts "ğŸ“Š Total: #{all_master_keys.count} keys to manage"
puts

total_translations = 0
total_api_calls = 0

TARGET_LOCALES.each do |locale|
  puts "ğŸŒ Processing #{locale} (#{LANGUAGE_NAMES[locale]})..."

  target_file = File.join(LOCALES_DIR, "#{locale}.yml")
  cache_file = File.join(CACHE_DIR, "#{locale}.json")

  unless File.exist?(target_file)
    puts "   âš ï¸  #{locale}.yml does not exist, creating..."
    File.write(target_file, { locale => {} }.to_yaml)
  end

  target_data = YAML.load_file(target_file)
  target_keys = get_all_keys(target_data[locale] || {})

  # Find both missing keys AND keys with English values (untranslated)
  missing_keys = all_master_keys.reject { |k, _v| target_keys.key?(k) }

  # Find keys that exist but have the same value as English (untranslated placeholders)
  english_placeholder_keys = {}
  target_keys.each do |k, v|
    if all_master_keys.key?(k) && v == all_master_keys[k]
      english_placeholder_keys[k] = v
    end
  end

  # Combine both types of keys that need translation
  keys_needing_translation = missing_keys.merge(english_placeholder_keys)

  if keys_needing_translation.empty?
    puts "   âœ… All translations present (#{target_keys.count} keys)"
    next
  end

  puts "   ğŸ“ Found #{missing_keys.count} missing keys"
  if english_placeholder_keys.any?
    puts "   ğŸ”„ Found #{english_placeholder_keys.count} untranslated (English placeholder) keys"
  end
  puts "   ğŸ“‹ Total keys to translate: #{keys_needing_translation.count}"

  # Process in batches
  keys_needing_translation.each_slice(BATCH_SIZE).with_index do |batch, index|
    batch_hash = batch.to_h
    puts "   ğŸ“¦ Batch #{index + 1}/#{(keys_needing_translation.size.to_f / BATCH_SIZE).ceil} (#{batch_hash.size} keys)"

    translations = translate_batch(batch_hash, locale, client, cache_file)
    total_api_calls += 1

    next unless translations

    # Apply translations with validation
    translations.each do |key, value|
      if validate_translation(key, batch_hash[key], value)
        set_nested_key(target_data[locale] ||= {}, key, value)
        total_translations += 1
      else
        # Validation failed - this is a critical error
        puts "      âŒ CRITICAL: Translation validation failed for key: #{key}"
        puts "         Original: #{batch_hash[key]}"
        puts "         Translated: #{value}"
        puts "      This is unacceptable - translations must preserve variables correctly"
        exit 1
      end
    end

    # Small delay between batches to avoid rate limiting
    sleep 0.5 if index < (keys_needing_translation.size.to_f / BATCH_SIZE).ceil - 1
  end

  # Write updated locale file
  File.write(target_file, target_data.to_yaml)
  puts "   ğŸ’¾ Updated #{locale}.yml"
  puts
end

puts "=" * 80
puts "âœ¨ Translation Complete!"
puts "=" * 80
puts "ğŸ“Š Statistics:"
puts "   â€¢ Languages processed: #{TARGET_LOCALES.size}"
puts "   â€¢ Total translations: #{total_translations}"
puts "   â€¢ API calls made: #{total_api_calls}"
puts "   â€¢ Cache directory: #{CACHE_DIR}"
puts
puts "ğŸ’¡ Next steps:"
puts "   1. Review the updated locale files"
puts "   2. Run 'bin/rails test' to ensure nothing broke"
puts "   3. Commit the changes if everything looks good"
puts
